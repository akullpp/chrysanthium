<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REST and gRPC in parallel || Chrysanthium</title>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/post.css">
    <link rel="stylesheet" href="/css/tomorrow.css">
  </head>

  <body>
    <header class="navigation">
      <ul>
        <li>
          <a href="/">Blog</a>
        </li>

        <li>
          <a href="/about">About</a>
        </li>
      </ul>
    </header>

    <h1>REST and gRPC in parallel</h1>
    
      <h6>2021/05</h6>
    

    <p>I love to use gRPC for inter-service communication since it is very efficient and often a good alternative to messaging solutions like Kafka. It utilizes Protobuf and HTTP2 which brings a lot of benefits such as strong typing, versioning and streaming.</p>
<p>Nevertheless, it is often the case that I also need to provide REST and/or GraphQL endpoints for other consumers.</p>
<p>A simple solution is to utilize <a href="https://github.com/soheilhy/cmux">cmux</a>, a library that allows to multiplex connections based on their payload. This way I can provide every protocol on the same TCP listener:</p>
<pre class="language-shell"><code class="language-shell">go get github.com/soheilhy/cmux</code></pre>
<p>For implementing a lightweight REST API I recommend using <a href="https://github.com/labstack/echo">echo</a>:</p>
<pre class="language-shell"><code class="language-shell">go get github.com/labstack/echo/v4</code></pre>
<p>Of course you will also need the gRPC dependencies:</p>
<pre class="language-shell"><code class="language-shell">go get google.golang.org/grpc
go get google.golang.org/protobuf</code></pre>
<p>Assume we are inside the main function. Let us start with creating the default listener first:</p>
<pre class="language-go"><code class="language-go">port <span class="token operator">:=</span> <span class="token string">":8000"</span>

l<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>Then we initialize the multiplexer:</p>
<pre class="language-go"><code class="language-go">m <span class="token operator">:=</span> cmux<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>
grpcL <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>cmux<span class="token punctuation">.</span><span class="token function">HTTP2HeaderField</span><span class="token punctuation">(</span><span class="token string">"content-type"</span><span class="token punctuation">,</span> <span class="token string">"application/grpc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
httpL <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Match</span><span class="token punctuation">(</span>cmux<span class="token punctuation">.</span><span class="token function">HTTP1Fast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Based on the <code>content-type</code> header we use gRPC+HTTP/2 or as fallback the HTTP/1.1 listener.</p>
<p>First we create the gRPC server and service:</p>
<pre class="language-go"><code class="language-go">grpcS <span class="token operator">:=</span> grpc<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// some service based on your proto</span></code></pre>
<p>And second the &quot;normal&quot; HTTP server, in my case a REST API with echo:</p>
<pre class="language-go"><code class="language-go">e <span class="token operator">:=</span> echo<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// some middleware, routes and handlers</span>
httpS <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>
    Handler<span class="token punctuation">:</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>resp http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span> req<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code></pre>
<p>Then we run the respective protocol servers with the muxed listeners in go routines:</p>
<pre class="language-go"><code class="language-go"><span class="token keyword">go</span> grpcS<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>grpcL<span class="token punctuation">)</span>
<span class="token keyword">go</span> httpS<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>httpL<span class="token punctuation">)</span></code></pre>
<p>And finally start serving:</p>
<pre class="language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Listening on %s\n"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span>
m<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>


    <footer class="navigation">
      <ul>
        <li>
          <a href="/privacy">Privacy</a>
        </li>

        <li>
          <a href="/legal">Legal</a>
        </li>
      </ul>
    </footer>
  </body>
</html>
