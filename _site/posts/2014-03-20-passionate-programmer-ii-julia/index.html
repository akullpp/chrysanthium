<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Passionate Programmer II: At The Edge with Julia || Chrysanthium</title>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/post.css">
    <link rel="stylesheet" href="/css/tomorrow.css">
  </head>

  <body>
    <header class="navigation">
      <ul>
        <li>
          <a href="/">Blog</a>
        </li>

        <li>
          <a href="/about">About</a>
        </li>
      </ul>
    </header>

    <h1>The Passionate Programmer II: At The Edge with Julia</h1>
    
      <h6>2014/03</h6>
    

    <p>If you read the post about becoming <a href="/act-on-it">a passionate programmer</a>, you also read the advice to try a new language. Although I recommend to learn a more common language which you haven't had the chance to look at yet, you could also try one of those bleeding edge languages for fun and profit. It also provides you with the excellent opportunity to engage in open source activities and develop libraries or the language itself.</p>
<p>I'd like to give you a short introduction to a relatively new programming language which I think looks promising and was recently featured in a <a href="http://www.wired.com/wiredenterprise/2014/02/julia/">Wired article</a>. We will focus on the differences of this bleeding edge language and compare it to the most common mainstream languages.</p>
<p>I'm certainly not an expert regarding this language and just a humble learner myself, therefore I'm not able to cover the intrinsic issues which may lie deep inside the implementation of the theoretical concepts. All I want is to provide a short glimpse why this particular language might be worth a second look.</p>
<h2>Overview</h2>
<p>This multi-paradigm language appeared in 2012 and is strongly influenced by Lisp and Python. In a negative sense, MATLAB and particular R also played a major role in the development of Julia since the speed and/or usability of languages designed for statistics are often abysmal. Its intention is to provide high-performance numerical and scientific computing while having the advantages of a dynamic language. Currently, it is being hyped as &quot;C for data scientists&quot;.</p>
<h2>Advantages</h2>
<ul>
<li>Fast</li>
<li>Easy to learn and readable syntax</li>
<li>Dynamic, clean type system with promotion</li>
<li>Homoiconicity and macros</li>
<li>Multiple dispatch</li>
<li>Connectivity to other language libraries</li>
<li>Optimized for numerical operations</li>
<li>Standard library written in Julia</li>
</ul>
<h2>Features</h2>
<h3>Fast</h3>
<p>The developers provide detailed information on their <a href="http://julialang.org/">website</a> and indeed it is within reach of C as we can validate with a simple recursive fibonacci that takes twice as long as the C pendant.</p>
<p>The main point with the speed of Julia and the comparison with other languages is to write unvectorized code. If you optimize and vectorize your code in Python you are as fast as Julia if not a little bit faster.</p>
<p>It compiles to <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> bytecode which not only means speed improvements but also increases potential portability and interoperability.</p>
<h3>Syntax &amp; Types</h3>
<p>The syntax is essentially the same as Python and therefore as readable and easy to use. In fact, this strongly favors Julia since you often need to write <a href="https://en.wikipedia.org/wiki/Cython">Cython</a> anyway in critical situations.</p>
<p>The clear advantage of Julia as compared to Python is the clean type and promotion system. Python has an awful type system which was <a href="http://legacy.python.org/dev/peps/pep-3119/">tacked on later</a> while Julia had the advantage to learn from the mistakes of its predecessors and integrated a well rounded system.</p>
<h3>Homoiconicity</h3>
<p>The concept of metaprogramming as specified by Lisp in 1958 is fundamental and states that programs are represented as datastructures of the language itself. Therefore, assembly is <a href="http://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a>. Julia is also homoiconic which means a program can write a program, including itself. It can transform and generate its own code and reflect it.</p>
<h3>Multiple Dispatch</h3>
<p>Methods are not functions. A function maps arguments to a return value, e.g. the addition function is conceptually the same for integers and floating points but are implemented differently regarding their behavior. These behavior-driven implementations are methods which can depend on the type, order or count. The choice which method to use, is called <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">(multiple) dispatching</a>.</p>
<p>Let us look at a passage from the Julia manual:</p>
<blockquote>
<p>In C++ or Java, for example, in a method call like <code>obj.meth(arg1,arg2)</code>, the object <code>obj</code> &quot;receives&quot; the method call and is implicitly passed to the method via the this keyword, rather then as an explicit method argument. When the current this object is the receiver of a method call, it can be omitted altogether, writing just <code>meth(arg1,arg2)</code>, with this implied as the receiving object.</p>
</blockquote>
<p>This doesn't sound like much, but it's big and allows for decoupling complex algorithms from implementation details. The set of methods is not closed, you can create or remove methods based on behavior. Out of all applicable methods, you can choose the effective method at runtime. For implementation details, check below.</p>
<h3>Connectivity</h3>
<p>You can just call Fortran and C code from Julia, no glue code involved.</p>
<p>Other languages have packages, so that you can for example <a href="http://blog.leahhanson.us/julia-calling-python-calling-julia.html">call Python calling Julia</a>.</p>
<h3>The Standard Library</h3>
<p>Julia's standard library is written in Julia.</p>
<p>This is a big deal since a native implementation reduces overhead from system library calls, which is important in a  high-performance language. Furthermore, the source code is simpler to read and to understand. If you know Python and want to work on the Core or a library like NumPy, you can't. It is entirely written in C which is a disadvantage for many people.</p>
<p>Currently the Julia environment is of course not as rich as R. To be honest, there might be not many programmers that actually like R, but what you definitely do like, is the vast code base. Would you rather implement MCMC from scratch in R or Python? The only way to fix this, is to get involved and create packages.</p>
<h2>A Look Inside</h2>
<h3>Datatypes and Operators</h3>
<p>The datatypes and operators are just like you would expect and for your sanity omitted. Additionally, we have a rational type that reduces to the lowest term thanks to the type system:</p>
<pre class="language-julia"><code class="language-julia">julia<span class="token operator">></span> <span class="token number">3</span><span class="token operator">//</span><span class="token number">6</span>
<span class="token number">1</span><span class="token operator">//</span><span class="token number">2</span></code></pre>
<p>Int divided by Int results in a Float:</p>
<pre class="language-julia"><code class="language-julia"><span class="token number">5</span><span class="token operator">/</span><span class="token number">2</span> <span class="token comment"># 2.5</span></code></pre>
<p>Strings are an array unicode chars. This will result in some peculiarities since UTF-8 uses more than a single byte for characters:</p>
<pre class="language-julia"><code class="language-julia"><span class="token string">"Jül"</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># 'J'</span>
<span class="token string">"Jül"</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment"># 'ü'</span>
<span class="token string">"Jül"</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment"># ERROR: invalid UTF-8 character index</span>
<span class="token string">"Jül"</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment"># 'l'</span></code></pre>
<p>Like Perl, we have string interpolation:</p>
<pre class="language-julia"><code class="language-julia"><span class="token string">"1 + 1 = $(1 + 1)"</span> <span class="token comment"># equal to "1 + 1 = 2"</span></code></pre>
<p>Variable names support unicode, start with a letter and can contain digits, underscores and exclamation marks:</p>
<pre class="language-julia"><code class="language-julia">julia<span class="token operator">></span> ಠ_ಠ <span class="token operator">=</span> bits<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token string">"0000000000000000000000000000000000000000000000000000000000000000"</span></code></pre>
<p>If a variable is preceded by a numeric literal, it implies multiplication:</p>
<pre class="language-julia"><code class="language-julia"><span class="token number">2</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre>
<p>Which also adds a lot of possible confusion with juxtaposition:</p>
<p>(x-1)(x+1) # type error: apply: expected Function, got Int64</p>
<p>You can create constants with <code>const</code> which is only necessary for optimization of global variables.</p>
<p>Chain comparisons are allowed:</p>
<p>1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5 # true</p>
<p>Julia is an 1-index language which is common in statistically-oriented languages. One dimensional array notation is as expected, two dimensional arrays are semicolon-separated:</p>
<p>vector = [1, 2]
vector[end] # last index
matrix = [1 2; 3 4]
push!(vector, 3) # results in vector = [1, 2, 3]</p>
<p>Functions with exclamation mark indicate that they modify their argument.</p>
<p>We also have the possibility to use multidimensional arrays, e.g.:</p>
<p>julia&gt; x = reshape(1:16, 4, 4)
4x4 Int64 Array
1 5  9 13
2 6 10 14
3 7 11 15
4 8 12 16</p>
<p>julia&gt; x[2:3, 2:end-1]
2x2 Int64 Array
6 10
7 11</p>
<p>Of course it is possible to call BLAS or LAPACK functions if they are not implemented in Julia and we have special structures, e.g. <a href="http://en.wikipedia.org/wiki/Sparse_matrix">sparse matrices</a>.</p>
<p>Further array and tuple methods, ranges, un/packing and slicing are similar to Python. Dictionaries also behave similar but the notation differs:</p>
<p>for (k, v) in [&quot;one&quot;=&gt;1,&quot;two&quot;=&gt;2,&quot;three&quot;=&gt;3]
println(&quot;$k = $v&quot;)
end</p>
<p>Indentation has no semantic meaning and block/control-statements close with an <code>end</code>.</p>
<p>Like Python, we have list comprehensions - except we don't have an <code>if</code> clause:</p>
<p>[f(10)(i) for i = [1:5]] # [11, 12, 13, 14, 15]</p>
<h3>Functions</h3>
<p>Julia has <a href="https://en.wikipedia.org/wiki/First-class_function">first-class functions</a> which can be anonymous and are defined as follows:</p>
<p>function f(x)
function g(y)
x + y
end
g
end</p>
<p>julia&gt; f(10)(3)
13</p>
<p>As we can see the <code>return</code> keyword is optional and the default is to return the last statement.</p>
<p>The function above is equal two following lambda syntax:</p>
<p>function f(x)
y -&gt; x + y
end</p>
<p>We also have the option to pass anonymous functions to other functions as arguments:</p>
<p>map([A, B, C]) do x
if x &lt; 0 &amp;&amp; iseven(x)
return 0
elseif x == 0
return 1
else
return x
end
end</p>
<p>Compound expressions are a neat way to do one-liners:</p>
<p>(x = 1; y = 2; x + y) # 3</p>
<p>Coroutines can be suspended and resumed:</p>
<p>function producer()
for n = 1:5
produce(2n)
end
end</p>
<p>p = Task(producer)
consume(p) # 2
consume(p) # 4
consume(p) # 6
consume(p) # 8
consume(p) # 10</p>
<p>Furthermore and unfortunately too extensive to cover here, we have a myriad of <a href="http://docs.julialang.org/en/release-0.2/stdlib/base/#mathematical-functions">build-in mathematical functions</a> like<a href="http://en.wikipedia.org/wiki/Machine_epsilon"> machine epsilon</a>.</p>
<h3>Types</h3>
<p>Julia has a rich type system with promotion where every type is placed within a hierarchy:</p>
<p>typeof(5) # Int64
typeof(Int64) # DataType
typeof(DataType) # DataType</p>
<p>super(5) # Int64
super(Int64) # Signed
super(Signed) # Real
super(Real) # Number
super(Number) # Any
super(Any) # Any</p>
<p>subtypes(Signed) # [Int128, Int16, Int32, Int64, Int8]</p>
<p>A type is set with the <code>::</code> operator and can be attached to non-variables as assertion. If we don't set an explicit type, it will default to <code>::Any</code>.</p>
<p>We can also define our own types. Let us begin with defining an abstract type. An abstract has no instantiation since it is just a node in the type graph:</p>
<p>abstract Integer &lt;: Number
You can define your own bits types:
bitstype 32 Float32 &lt;: FloatingPoint</p>
<p>Like C, Julia has structures which are really composite types, i.e. a collection of named fields. Additionally, the structures can be immutable or be part of a union. Please note, that there are no functions attached to a structure since we have multiple dispatching:</p>
<p>type Product
price::Float32
name
end</p>
<p>p = Product(32., &quot;Gadget&quot;)
p.name # &quot;Gadget&quot;</p>
<p>Although not advised, you can define the constructor within the block:</p>
<p>type UniquePair
x::Number
y::Number</p>
<p>Pair(x,y) = x == y ? error(&quot;Arguments with same values&quot;) : new(x,y)
end</p>
<p>You can add functionality by defining a new constructor method:</p>
<p>UniquePair(x) = UniquePair(x,x) # distributes the argument to both fields</p>
<p>UniquePair() = UniquePair(0, 1) # sets a default constructor method</p>
<p>Regarding generics Julia is very similar to Java's templating:</p>
<p>type Point{T}
x::T
y::T
end</p>
<h3>Methods</h3>
<p>Julia allows to choose the method based on the type of arguments. This is called multiple dispatching and one critical feature of Julia. If you have a look at the addition function you see how many methods it has:</p>
<p>julia&gt; methods(+)
# 92 methods for generic function &quot;+&quot;:
+(x::Bool,y::Bool) at bool.jl:38
...
+(x::Int128,y::Int128) at int.jl:43
...</p>
<p>Defining a method is simple:</p>
<p>f(x::Float64, y::Float64) = 2x + y
f(2.0, 3.0) # 7.0
f(2.0, 3) # no method f(Float64,Int64)</p>
<p>You can of course define a more abstract type and delegate the details to the arithmetic operation or use parametrics. However, specific behavior always overrules general. In our example, the method for floating point numbers would be used if possible instead of a more general one.</p>
<h3>Modules</h3>
<p>One example to show almost the entire functionality of creating modules:</p>
<p>module PointModule
using Lib
export Point, f</p>
<p>type Point
x
y
end</p>
<p>g(x,y) = x * y
f(p::Point) = g(p.x,p.y)</p>
<p>import Base.show</p>
<p>show(io:IO, p::Point) = print(io, &quot;Point: x=$(p.x), y=$(p.y)&quot;)</p>
<p>end</p>
<p>First we define the name of the modul, the standard library which is used for searching and which parts we would like to make public. Finally, we define types and functions. The module is used with:</p>
<p>julia&gt; Name.Pair(1,2)
Pair: x=1, y=2</p>
<p>Name.f(p) # 2</p>
<h3>Metaprogramming</h3>
<p>Julia programs are represented as Julia data structures of the expression type:</p>
<p>type Expr
head::Symbol
args::Array{Any,1}
typ
end</p>
<p>With the definition of:</p>
<p>julia&gt; a = 1
1</p>
<p>julia&gt; :(a + 2)
:(a + 1)</p>
<p>julia&gt; eval(ans)
2</p>
<p>julia&gt; Expr(:call, :+, a, 1) # equivalent to shorthand :($a + 1)
:(1 + 1)</p>
<p>julia&gt; eval(ans)
2</p>
<p>This allows us to generate code from inside the language. Take for example the definition of the addition- and subtraction-function for three arguments which refer to the two argument form:</p>
<p>for op = (:+, :-)
eval(:(($op)(a,b,c) = ($op)(($op)(a,b),c)))
end</p>
<p>Macros are convenient to generate code at compile time:</p>
<p>macro assert(ex)
:($ex ? nothing : error(&quot;Assertion failed: &quot;, $(string(ex))))
end</p>
<p>julia&gt; @assert 1 == 0 # 1 == 0 ? nothing : error(&quot;Assertion failed: &quot;, &quot;1 == 0&quot;)
Assertion failed: 1 == 0</p>
<h3>And More...</h3>
<p>Julia has immense capabilities for <a href="http://docs.julialang.org/en/release-0.2/manual/parallel-computing/">parallel computing</a>.</p>
<p>It can run external commands with the full implications, e.g. <code>run(`ls`)</code>.</p>
<p>You can <a href="http://docs.julialang.org/en/release-0.2/manual/calling-c-and-fortran-code/">call C and Fortran functions</a> without glue code.</p>
<p>If you need packages, it even has a <a href="http://docs.julialang.org/en/release-0.2/manual/packages/">build-in package manager</a>.</p>


    <footer class="navigation">
      <ul>
        <li>
          <a href="/privacy">Privacy</a>
        </li>

        <li>
          <a href="/legal">Legal</a>
        </li>
      </ul>
    </footer>
  </body>
</html>
