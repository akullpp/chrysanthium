<!doctype html>
<html lang="en">
  <head>
    <title>Multiple SPAs at different paths accessible through a gateway || Chrysanthium</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="akullpp" />
    <meta name="description" content="About software engineering" />
    <meta name="email" content="akullpp@gmail.com" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:creator" content="" />
    <meta name="twitter:title" content="Multiple SPAs at different paths accessible through a gateway" />
    <meta name="twitter:image" content="https://chrysanthium.com/logo.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/post.css">
    <link rel="stylesheet" href="/css/tomorrow.css">
  </head>

  <body>
    <header class="navigation">
      <ul>
        <li>
          <a href="/">Blog</a>
        </li>

        <li>
          <a href="/about">About</a>
        </li>
      </ul>
    </header>

    <h1>Multiple SPAs at different paths accessible through a gateway</h1>
    
      <h6>2018/04</h6>
    

    <p>Normally, you would serve one SPA at a specific domain but sometimes the differentiating criteria has to be the path while the host (e.g. <code>http://www.example.test</code>) stays the same which means one application should be available at <code>/foo</code> and the other at <code>/bar</code>. If you do not want to read the whole explanation how to fix this, you can find the code of my solution on <a href="https://github.com/akullpp/multiple-react-nginx">GitHub</a>.</p>
<h2>Workarounds</h2>
<p>Unfortunately <a href="https://github.com/facebook/create-react-app">create-react-app</a> does not support this endeavor yet and there are a dozen issues on their GitHub with new ones created regularly. If you build an CRA project you will find the following epilogue:</p>
<pre><code>The project was built assuming it is hosted at 'the server root'.
You can control this with the homepage field in your package.json.
</code></pre>
<p>Which leads to absolute paths in the <code>build/index.html</code>:</p>
<pre><code>/static/css/main.c17080f1.css
/static/js/main.37de2feb.js
</code></pre>
<p>Of course these will not resolve on the server if you serve at a specific path.</p>
<p>The first solution would be abusing the <code>homepage</code> property in the <code>package.json</code> and making it relative by setting it to <code>&quot;.&quot;</code> which will result in:</p>
<pre><code>./static/css/main.c17080f1.css
./static/js/main.37de2feb.js
</code></pre>
<p>However the <a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment">CRA user guide</a> also states that this is only sensible &quot;if you are not using the HTML5 pushState history API or not using client-side routing at all&quot; since URLs can be arbitrary and deeply nested which cannot be known in advance by the router.</p>
<p>Another option would be to use <a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/api/HashRouter.md">hash routing</a> which adds <code>#</code> to your URL like in the old times with AngularJS. There is nothing too wrong about that, but I actually want to be able to use the HTML5 API to full extent.</p>
<p>So I will solve this by using absolute paths, however, I do not want to actually abuse the <code>homepage</code> field inside the <code>package.json</code> because it defies its semantics and syntax.</p>
<h2>Solution</h2>
<p>My suggestion is using the <code>PUBLIC_URL</code> environment variable which will substitute the <code>%PUBLIC_URL%</code> variables in the template <code>public/index.html</code> during the build phase. Alternatively, you can also add the variable to <code>.env</code> files, one for each environment, and choose the correct one during build-time but this gets ugly fast. However this means you have to rebuild each time you want to host it under a different location. For me, this is more like a theoretical limitation.</p>
<p>Unfortunately, the DevOps part is littered with pitfalls so I decided to write an explicit example for the following containerized components:</p>
<p><img src="images/components.png" alt="full"></p>
<p>with the following relevant folder structure:</p>
<pre><code>vm/
  docker-compose.yml
  foo/
    // stuff by create-react-app init
    nginx.conf
    Dockerfile
  bar/
    // stuff by create-react-app init
    nginx.conf
    Dockerfile
  gateway/
    nginx.conf
    Dockerfile
</code></pre>
<h2>SPA configuration</h2>
<p>The two SPAs <code>foo</code> and <code>bar</code> were created with CRA and <code>bar</code> does client-side routing with <code>react-router-dom</code> and nested paths. The following paths should be resolved and routed to the correct container without trailing slashes or other invalid fragments:</p>
<pre><code>/foo
/foo/
/bar
/bar/
/bar/routeA
/bar/routeB
/bar/routeB/1
/bar/routeB/2
/bar/routeB/2
</code></pre>
<p>In order to use client-side routing we just need to set the <a href="https://reacttraining.com/react-router/web/api/BrowserRouter/basename-string"><code>basename</code> attribute</a> of your aliased <code>BrowserRouter</code>:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Router</span></span> <span class="token attr-name">basename</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">PUBLIC_URL</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
</span></code></pre>
<p>This will not impact local development since the environment variable will only be set by the CI during build. That is the only modification we need on the client.</p>
<p>Each SPA is build as a Docker container and served by an nginx with the identical <code>Dockerfile</code> configurations:</p>
<pre class="language-docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> node <span class="token keyword">as</span> builder</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /var/lib/app/</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./package.json ./</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./yarn.lock ./</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./src/ ./src</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./public/ ./public</span>

<span class="token instruction"><span class="token keyword">ARG</span> PUBLIC_URL</span>
<span class="token instruction"><span class="token keyword">RUN</span> yarn --frozen-lockfile --no-cache --production --ignore-optional</span>
<span class="token instruction"><span class="token keyword">RUN</span> yarn run build</span>

<span class="token instruction"><span class="token keyword">FROM</span> nginx</span>

<span class="token instruction"><span class="token keyword">COPY</span> nginx.conf /etc/nginx/nginx.conf</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">builder</span></span> /var/lib/app/build/ /var/www/</span></code></pre>
<p>I use a <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage build</a> since <code>node</code> is only required for the build but you could also serve the files with <a href="https://www.npmjs.com/package/serve">serve</a> like CRA suggests and keep the image. I am quite verbose with the <code>COPY</code> instructions but I like to be explicit here and not add everything in order to keep side-effects to a minimum.</p>
<p>The important part is the build argument <code>PUBLIC_URL</code> which will be injected by your CI if it builds your container and pushes it to a registry. I simulate this by the <code>docker-compose.yml</code> in the root of the <code>vm</code> folder for convenience and demonstration purposes.</p>
<p>The <a href="https://github.com/akullpp/multiple-react-nginx/blob/master/vm/bar/nginx.conf"><code>nginx.conf</code></a> files for each SPA look pretty minimal too and will just serve the folder under the root, no path specific configuration here.</p>
<p>The interesting pitfall lies in the <a href="https://github.com/akullpp/multiple-react-nginx/blob/master/vm/gateway/nginx.conf"><code>nginx.conf</code></a> of the <code>gateway</code> which is the reverse proxy to our applications. You might be tempted to just do this:</p>
<pre class="language-nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /foo</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://vm_foo_1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Which is not only inconvenient but will also lead to requests with double slashes upstream, e.g. <code>//static/css/main.c17080f1.css</code>. This will become an issue if you do fancier folder structures. In this scenario there would be no impact since the upstream nginx, which functions as static file server, interprets it correctly. The <a href="(http://nginx.org/en/docs/http/ngx_http_core_module.html#location)">documentation</a> enlightens us about this behavior:</p>
<blockquote>
<p>If a location is defined by a prefix string that ends with the slash character, and requests are processed by one of proxy_pass [...] then the special processing is performed. In response to a request with URI equal to this string, but without the trailing slash, a permanent redirect with the code 301 will be returned to the requested URI with the slash appended.</p>
</blockquote>
<p>Luckily they also include a fix which is the duplication of the <code>location</code> with a trailing slash:</p>
<pre class="language-nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /bar/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://vm_bar_1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> /bar</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://vm_bar_1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> /foo/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://vm_foo_1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> /foo</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://vm_foo_1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>The only thing left is to build and push the individual containers to a registry which is a job for your CI. If you want to do this manually you would do something like:</p>
<pre class="language-shell"><code class="language-shell"><span class="token function">docker</span> build --build-arg <span class="token assign-left variable">PUBLIC_URL</span><span class="token operator">=</span><span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token builtin class-name">.</span></code></pre>
<p>This builds the container of the SPA with the correct <code>PUBLIC_URL</code> which will lead to valid requests, e.g. <code>&lt;PUBLIC_URL&gt;/static/css/main.c17080f1.css</code> and routing on the server.</p>
<p>However as I explained earlier the <a href="https://github.com/akullpp/multiple-react-nginx/blob/master/vm/docker-compose.yml"><code>docker-compose.yml</code></a> at the root does this for convenience and demonstration purpose, e.g.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">bar</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span>
      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./bar
      <span class="token key atrule">args</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> PUBLIC_URL=/bar
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> test</code></pre>


    <footer class="navigation">
      <ul>
        <li>
          <a href="/privacy">Privacy</a>
        </li>

        <li>
          <a href="/legal">Legal</a>
        </li>
      </ul>
    </footer>
  </body>
</html>
